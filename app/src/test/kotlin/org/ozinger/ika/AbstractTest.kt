package org.ozinger.ika

import io.mockk.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.extension.RegisterExtension
import org.koin.core.component.inject
import org.koin.test.KoinTest
import org.koin.test.junit5.KoinTestExtension
import org.koin.test.junit5.mock.MockProviderExtension
import org.koin.test.mock.declareMock
import org.ozinger.ika.configuration.Configuration
import org.ozinger.ika.definition.ServerId
import org.ozinger.ika.definition.ServerUserId
import org.ozinger.ika.definition.UniversalUserId
import org.ozinger.ika.event.PacketReceiver
import org.ozinger.ika.event.PacketSender
import org.ozinger.ika.handler.HandlerProcessor
import org.ozinger.ika.koin.*
import org.ozinger.ika.networking.Packet

abstract class AbstractTest : KoinTest {
    private val handlerProcessor: HandlerProcessor by inject()
    private val packetReceiver: PacketReceiver by inject()
    protected val configuration: Configuration by inject()

    protected val remoteServerId = ServerId("123")
    protected val localUser1Id = UniversalUserId(ServerId("012"), ServerUserId("AAAAAA"))
    protected val remoteUser2Id = UniversalUserId(remoteServerId, ServerUserId("BBBBBB"))
    protected val remoteUser3Id = UniversalUserId(remoteServerId, ServerUserId("CCCCCC"))

    private val packetTestScope: PacketTestScope by lazy { PacketTestScope() }

    @JvmField
    @RegisterExtension
    val koinTestExtension = KoinTestExtension.create {
//        printLogger(Level.DEBUG)
        modules(configurationModule)
        modules(eventModule, definitionModule, storeModule)
        modules(autoGeneratedHandlerModule)
    }

    @JvmField
    @RegisterExtension
    val mockProvider = MockProviderExtension.create { clazz ->
        mockkClass(clazz)
    }

    protected fun packetTest(block: PacketTestScope.() -> Unit) {
        packetTestScope.block()
    }

    inner class PacketTestScope {
        private val sentPackets = mutableListOf<Packet>()

        init {
            declareMock<PacketSender> {
                coEvery { put(capture(sentPackets)) } just Runs
                coEvery { sendDirect(any()) } answers { invocation.originalCall() }
                coEvery { sendAsServer(any()) } answers { invocation.originalCall() }
                coEvery { sendAsUser(any(), any()) } answers { invocation.originalCall() }
                every { this@declareMock getProperty "configuration" } returns configuration
            }
        }

        fun assumeAsReceived(packet: Packet, assertions: (List<Packet>) -> Unit = {}) {
            sentPackets.clear()

            runBlocking {
                launch { packetReceiver.put(packet) }
                handlerProcessor.handle()
            }

            assertions(sentPackets)
        }

        fun assumeAsReceivedSequencially(vararg packets: Packet, assertions: (List<Packet>) -> Unit = {}) {
            sentPackets.clear()

            runBlocking {
                launch { packets.forEach { packetReceiver.put(it) } }
                repeat(packets.size) {
                    handlerProcessor.handle()
                }
            }

            assertions(sentPackets)
        }
    }
}