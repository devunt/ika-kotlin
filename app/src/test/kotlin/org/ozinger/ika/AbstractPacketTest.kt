package org.ozinger.ika

import io.mockk.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.BeforeEach
import org.koin.core.Koin
import org.koin.core.component.inject
import org.koin.test.mock.declareMock
import org.ozinger.ika.definition.ChannelName
import org.ozinger.ika.definition.ServerId
import org.ozinger.ika.definition.ServerUserId
import org.ozinger.ika.definition.UniversalUserId
import org.ozinger.ika.event.PacketReceiver
import org.ozinger.ika.event.PacketSender
import org.ozinger.ika.handler.HandlerProcessor
import org.ozinger.ika.koin.*
import org.ozinger.ika.networking.Packet

abstract class AbstractPacketTest : AbstractTest() {
    private val handlerProcessor: HandlerProcessor by inject()
    private val packetReceiver: PacketReceiver by inject()

    private val sentPackets = mutableListOf<Packet>()

    protected val remoteServerId = ServerId("123")
    protected val localUser1Id = UniversalUserId(ServerId("012"), ServerUserId("AAAAAA"))
    protected val remoteUser2Id = UniversalUserId(remoteServerId, ServerUserId("BBBBBB"))
    protected val remoteUser3Id = UniversalUserId(remoteServerId, ServerUserId("CCCCCC"))
    protected val channel1Name = ChannelName("#test")
    protected val channel2Name = ChannelName("#test2")

    @BeforeEach
    fun setUpSuper(koin: Koin) {
        koin.loadModules(listOf(eventModule, storeModule, autoGeneratedHandlerModule))

        declareMock<PacketSender> {
            coEvery { put(capture(sentPackets)) } just Runs
            coEvery { sendDirect(any()) } answers { invocation.originalCall() }
            coEvery { sendAsServer(any()) } answers { invocation.originalCall() }
            coEvery { sendAsUser(any(), any()) } answers { invocation.originalCall() }
            every { this@declareMock getProperty "configuration" } returns configuration
        }
    }

    fun assumeAsReceived(packet: Packet, assertions: (List<Packet>) -> Unit = {}) {
        sentPackets.clear()

        runBlocking {
            launch { packetReceiver.put(packet) }
            handlerProcessor.handle()
        }

        assertions(sentPackets)
    }

    fun assumeAsReceivedSequencially(vararg packets: Packet, assertions: (List<Packet>) -> Unit = {}) {
        sentPackets.clear()

        runBlocking {
            launch { packets.forEach { packetReceiver.put(it) } }
            repeat(packets.size) {
                handlerProcessor.handle()
            }
        }

        assertions(sentPackets)
    }
}